//! A Rust proc macro to generate a enum wrapper for a set of types.
//!
//! `nodyn::wrap!` creates an enum for a set of types and generates method
//! and trait implementations.
//!
//! See the documentation of the macro for details: [`wrap!`].
//!
//! # Alternative crates
//!
//! - **`enum_dispatch`**
//!     - uses procedural macros
//!     - automatic `From` & `TryInto`
//!     - crate defined traits
//!     - only generate trait implementations for traits in scope
//!       in a very conveniant way.
//! - **`sum_type`**
//!     - declaritative macros
//!     - automatic `From` & `TryFrom`
//!     - no lifetimes
//!     - does not generate method or trait implementations

use proc_macro::TokenStream;
use quote::{quote, ToTokens};
use syn::spanned::Spanned;
use syn::{parse_macro_input, TypeArray, TypePath, TypeReference, TypeSlice};

mod impl_block;
mod multi_type;
mod trait_block;
mod variant;

pub(crate) use impl_block::ImplBlock;
pub(crate) use multi_type::MultiType;
pub(crate) use trait_block::TraitBlock;
pub(crate) use variant::Variant;

/// # Generated code
///
/// ## Variant types and names
///
/// Only Path, Reference, Array, Slice and Tuple types are allowed. The
/// variant names are created from the full path given converted
/// to camel case. Reference types have 'Ref', Arrays 'Array' + length
/// and Slices 'Slice' added.
///
/// ```
/// nodyn::wrap!{
///    #[derive(Debug)]
///    pub Foo<'a> {
///        i32,
///        String,
///        (u8, u8, u16),
///        [bool;4],
///        &'a str
///     }
/// }
///
/// let array: Foo = [true, true, false, true].into();
/// if let Foo::BoolArray4(inner) = array {
///     assert_eq!(inner, [true, true, false, true]);
/// } else {
///     unreachable!();
/// }
/// ```
///
/// ## Automatic generated trait implementations
///
/// 1. `From<T> for Wrapper` for all variant types
/// 2. `TryFrom<Wrapper> for T` automatic for all non reference types
///
///    When `T` has a `From<O>` implementation then you can add the
///    attribute `#[into(T)]` to `O` and it will return a `Some(T)` for it.
///
/// ### Example
///
/// ```
/// use core::convert::TryFrom;
///
/// nodyn::wrap! {
///     #[derive(PartialEq, Debug)]
///     pub Foo<'a> {
///         i64,
///         &'a str,
///         u32,
///         [u8;4],
///     }
/// }
///
/// let t2: Foo = 42u32.into();
/// assert_eq!(t2, Foo::U32(42));
/// let r2 = u32::try_from(t2);
/// assert_eq!(r2, Ok(42u32));
/// ```
///
/// ## Function delegation
///
/// When all types included implement a method, a delegation method
/// can be generated by including the method definition with the
/// block replaced by a semicolon in `impl`.
///
/// ## Trait implementation
///
/// When all types included implemen a trait. The trait can be implemented
/// for the wrapper:
///
#[proc_macro]
pub fn wrap(input: TokenStream) -> TokenStream {
    let multi_type = parse_macro_input!(input as MultiType);

    let e_num = multi_type.generate_enum();
    let from = multi_type.generate_from();
    let try_into = multi_type.generate_try_from();
    let impl_blocks = multi_type.generate_impl_blocks();
    let trait_blocks = multi_type.generate_trait_blocks();

    let expanded = quote! {
        #e_num
        #(#from)*
        #(#try_into)*
        #(#impl_blocks)*
        #(#trait_blocks)*
    };

    TokenStream::from(expanded)
}

fn ident_from_path(p: &syn::Path, extension: &str) -> syn::Ident {
    let idents: Option<Vec<String>> = p
        .segments
        .iter()
        .map(|p| {
            let ident = p.ident.to_string();
            let mut chars = ident.chars();
            chars
                .next()
                .map(|first| format!("{}{}{extension}", first.to_uppercase(), chars.as_str()))
        })
        .collect();
    idents
        .map(|s| syn::Ident::new(&s.concat(), p.span()))
        .expect("Could not generate ident")
}

fn syn_to_ident<T: ToTokens>(t: T) -> String {
    let input = t.to_token_stream().to_string();
    input
        .split_whitespace()
        .map(|word| {
            let filtered = word
                .chars()
                .filter(|c| c.is_alphanumeric())
                .collect::<String>();
            let mut chars = filtered.chars();
            chars
                .next()
                .map(|first| format!("{}{}", first.to_uppercase(), chars.as_str()))
                .expect("Could not uppercase first letter")
        })
        .collect::<Vec<String>>()
        .concat()
}

fn path_from_type(ty: &syn::Type) -> Option<&syn::Path> {
    match ty {
        syn::Type::Path(TypePath { path, .. }) => Some(path),
        syn::Type::Reference(TypeReference { elem, .. })
        | syn::Type::Array(TypeArray { elem, .. })
        | syn::Type::Slice(TypeSlice { elem, .. }) => path_from_type(elem),
        _ => None,
    }
}
